<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Yewdux</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Quickstart</li><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="example.html"><strong aria-hidden="true">2.</strong> Example</a></li><li class="chapter-item expanded affix "><li class="part-title">Usage</li><li class="chapter-item expanded "><a href="store.html"><strong aria-hidden="true">3.</strong> Store</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="persistence.html"><strong aria-hidden="true">3.1.</strong> Persistence</a></li></ol></li><li class="chapter-item expanded "><a href="dispatch.html"><strong aria-hidden="true">4.</strong> Dispatch</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reading.html"><strong aria-hidden="true">4.1.</strong> Subscriptions</a></li></ol></li><li class="chapter-item expanded "><a href="listeners.html"><strong aria-hidden="true">5.</strong> Listeners</a></li><li class="chapter-item expanded "><a href="tips.html"><strong aria-hidden="true">6.</strong> Tips</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="default_store.html"><strong aria-hidden="true">6.1.</strong> Setting default value</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Yewdux</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>A state management solution for the <a href="https://yew.rs">Yew</a> front-end library.</p>
<p>This crate was inspired by <a href="https://redux.js.org/">Redux</a>, however some deviation was taken in
the spirit of Rust.</p>
<p>This book is currently in development. If it is confusing in any way, or you have suggestions,
please post an issue in the <a href="https://github.com/intendednull/yewdux">repo</a> or ask in the
<a href="https://discord.gg/UmS6FKYa5a">Yew discord</a>.</p>
<h2 id="why-yewdux"><a class="header" href="#why-yewdux">Why Yewdux?</a></h2>
<p>State management in Yew can be difficult. Especially when many different components need access to
the same state. Properties and callbacks work great for simple relationships, however quickly become
cumbersome when you need to propagate state through many (potentially isolated) layers of
components. Yew's <a href="https://yew.rs/docs/concepts/contexts">context manager</a> does a decent job, and is
worth serious consideration, however it requires substantial boilerplate and is not that easy to
use.</p>
<p>This crate aims to provide a dead-simple, ergonomic approach to global state management. It
encourages modular state by providing easy setup and access to your shared state, allowing you to
write cleaner code while remaining productive.</p>
<p>It does <strong>not</strong> try to provide any additional patterns or features which aren't directly related to
accessing or manipulating shared state.</p>
<p>Yewdux was built with the following goals:</p>
<ul>
<li><strong>Simple</strong> - the only required trait is <a href="./store.html">Store</a>.</li>
<li><strong>Ergonomic</strong> - boilerplate is optional!</li>
<li><strong>Predictable</strong> - you have complete control over how state is changed.</li>
<li><strong>Selective</strong> - only render when you need to (see <a href="./reading.html#selectors">selectors</a>).</li>
<li><strong>Context agnostic</strong> - you can create and execute a <a href="./dispatch.html">dispatch</a> from anywhere.</li>
<li><strong>Complete component support</strong> - compatible with both functional and struct components.</li>
</ul>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<ul>
<li><a href="https://github.com/bounce-rs/bounce">Bounce</a> - The uncomplicated Yew State management library</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>Add Yewdux to your project's <code>Cargo.toml</code>. Make sure Yew has the &quot;csr&quot; feature (client side rendering):</p>
<h3 id="stable-release"><a class="header" href="#stable-release">Stable release:</a></h3>
<pre><code class="language-toml">[dependencies]
yew = { version = &quot;0.20&quot;, features = [&quot;csr&quot;] }
yewdux = &quot;0.9&quot;
</code></pre>
<h3 id="development-branch"><a class="header" href="#development-branch">Development branch:</a></h3>
<pre><code class="language-toml">[dependencies]
yew = { git = &quot;https://github.com/yewstack/yew.git&quot;, features = [&quot;csr&quot;] }
yewdux = { git = &quot;https://github.com/intendednull/yewdux.git&quot; }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart-example"><a class="header" href="#quickstart-example">Quickstart example</a></h1>
<p>Below you'll find a simple counter example, demonstrating how to read and write to shared state.
Only one component is shown here for simplicity, however keep in mind every other component that
uses the same <code>Counter</code> store type will share its state!</p>
<pre><pre class="playground"><code class="language-rust">use yew::prelude::*;
use yewdux::prelude::*;

#[derive(Debug, Default, Clone, PartialEq, Eq, Store)]
struct Counter {
    count: u32,
}

#[function_component]
fn App() -&gt; Html {
    let (counter, dispatch) = use_store::&lt;Counter&gt;();
    let onclick = dispatch.reduce_mut_callback(|counter| counter.count += 1);

    html! {
        &lt;&gt;
        &lt;p&gt;{ counter.count }&lt;/p&gt;
        &lt;button {onclick}&gt;{&quot;+1&quot;}&lt;/button&gt;
        &lt;/&gt;
    }
}

fn main() {
    yew::Renderer::&lt;App&gt;::new().render();
}
</code></pre></pre>
<h2 id="additional-examples"><a class="header" href="#additional-examples">Additional examples</a></h2>
<p>Complete working examples can be found in the
<a href="https://github.com/intendednull/yewdux/tree/0.8.1/examples">examples</a> folder of github.</p>
<p>To run an example you'll need to install <a href="https://github.com/thedodd/trunk">trunk</a> (a rust wasm
bundler), then run the following command (replacing [example] with your desired example name):</p>
<pre><code>trunk serve examples/[example]/index.html --open
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-a-store"><a class="header" href="#defining-a-store">Defining a Store</a></h1>
<p>A <a href="https://docs.rs/yewdux/0.8.1/yewdux/store/trait.Store.html">Store</a> represents state that is
shared application-wide. It is initialized on first access, and lives for application lifetime.</p>
<p>Implement <code>Store</code> for your state using the macro.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default, PartialEq, Store)]
struct Counter {
    count: u32,
}
<span class="boring">}
</span></code></pre></pre>
<p>It is also simple to define a <code>Store</code> manually. This is useful when you need finer control over how
it is created, or when to notify components.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq)]
struct Counter {
    count: u32,
}

impl Store for Counter {
    fn new() {
        Self {
            count: Default::default(),
        }
    }

    fn should_notify(&amp;self, old: &amp;Self) -&gt; bool {
        // When this returns true, all components are notified and consequently re-render.
        self != old
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><em>Note: implementing <code>Store</code> doesn't require any additional traits, however <code>Default</code> and
<code>PartialEq</code> are required for the macro.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="persistence"><a class="header" href="#persistence">Persistence</a></h1>
<p>Yewdux provides the <code>#[store]</code> macro to easily persist your state in either local or session storage.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use yewdux::prelude::*;
use serde::{Serialize, Deserialize};

#[derive(Default, PartialEq, Serialize, Deserialize, Store)]
#[store(storage = &quot;local&quot;)] // can also be &quot;session&quot;
struct Counter {
    count: u32,
}
<span class="boring">}
</span></code></pre></pre>
<p>This can also be done manually.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use yewdux::{prelude::*, storage};

impl Store for Counter {
    fn new() -&gt; Self {
        init_listener(storage::StorageListener::&lt;Self&gt;::new(storage::Area::Local));

        storage::load(storage::Area::Local)
            .expect(&quot;Unable to load state&quot;)
            .unwrap_or_default()
    }

    fn should_notify(&amp;self, other: &amp;Self) -&gt; bool {
        self != other
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="tab-sync"><a class="header" href="#tab-sync">Tab sync</a></h2>
<p>Normally if your application is open in multiple tabs, the store is not updated in any tab other
than the current one. If you want storage to sync in all tabs, add <code>storage_tab_sync</code> to the macro.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default, Clone, PartialEq, Eq, Deserialize, Serialize, Store)]
#[store(storage = &quot;local&quot;, storage_tab_sync)]
struct State {
    count: u32,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="additional-listeners"><a class="header" href="#additional-listeners">Additional Listeners</a></h2>
<p>You can inject additional listeners into the <code>#[store]</code> macro.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default, Clone, PartialEq, Eq, Deserialize, Serialize, Store)]
#[store(storage = &quot;local&quot;, listener(LogListener))]
struct State {
    count: u32,
}

struct LogListener;
impl Listener for LogListener {
    type Store = State;

    fn on_change(&amp;mut self, state: Rc&lt;Self::Store&gt;) {
        log!(Level::Info, &quot;Count changed to {}&quot;, state.count);
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dispatch"><a class="header" href="#dispatch">Dispatch</a></h1>
<p>A <a href="https://docs.rs/yewdux/0.8.1/yewdux/dispatch/struct.Dispatch.html">Dispatch</a> is the primary
interface to <a href="https://docs.rs/yewdux/0.8.1/yewdux/store/trait.Store.html">Store</a>. It is used to
read and write changes to state in various ways.</p>
<h1 id="creating-a-dispatch"><a class="header" href="#creating-a-dispatch">Creating a Dispatch</a></h1>
<p>To create a dispatch, you need only provide the desired store type.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dispatch = Dispatch::&lt;Counter&gt;::new();
<span class="boring">}
</span></code></pre></pre>
<p>A dispatch is also given when using the functional hook.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (state, dispatch) = use_store::&lt;Counter&gt;();
<span class="boring">}
</span></code></pre></pre>
<h1 id="changing-global-state-with-dispatch"><a class="header" href="#changing-global-state-with-dispatch">Changing global state with Dispatch</a></h1>
<p><code>Dispatch</code> provides many options for changing state.</p>
<h3 id="dispatchset"><a class="header" href="#dispatchset"><code>Dispatch::set</code></a></h3>
<p>Assign the store to the given value.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dispatch.set(Counter { count: 0 });
<span class="boring">}
</span></code></pre></pre>
<h3 id="dispatchset_callback"><a class="header" href="#dispatchset_callback"><code>Dispatch::set_callback</code></a></h3>
<p>Generate a callback that will set the store to a given value.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let onclick = dispatch.set_callback(|_| Counter { count: 0 });
html! {
    &lt;button {onclick}&gt;{&quot;Reset counter&quot;}&lt;/button&gt;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="dispatchreduce"><a class="header" href="#dispatchreduce"><code>Dispatch::reduce</code></a></h3>
<p>Assign the state of the store using a reducer function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dispatch.reduce(|counter| Counter { count: counter.count + 1});
<span class="boring">}
</span></code></pre></pre>
<h3 id="dispatchreduce_callback"><a class="header" href="#dispatchreduce_callback"><code>Dispatch::reduce_callback</code></a></h3>
<p>Generate a callback that assigns state using a reducer function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let onclick = dispatch.reduce_callback(|counter| Counter { count: counter.count + 1});
html! {
    &lt;button {onclick}&gt;{&quot;Increment (+1)&quot;}&lt;/button&gt;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="dispatchreduce_callback_with"><a class="header" href="#dispatchreduce_callback_with"><code>Dispatch::reduce_callback_with</code></a></h3>
<p>Similar to <code>Dispatch::reduce_callback</code>, but also includes the fired event.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let onchange = dispatch.reduce_callback_with(|counter, e: Event| {
    let input = e.target_unchecked_into::&lt;HtmlInputElement&gt;();

    if let Ok(count) = input.value().parse() {
        Counter { count }.into()
    } else {
        counter
    }
});

html! {
    &lt;input placeholder=&quot;Set counter&quot; {onchange} /&gt;
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="mutation-with-less-boilerplate-cow"><a class="header" href="#mutation-with-less-boilerplate-cow">Mutation with less boilerplate (CoW)</a></h1>
<p>There are <code>_mut</code> variants to every reducer function. This way has less boilerplate, and requires
your <code>Store</code> to implement <code>Clone</code>.</p>
<h3 id="dispatchreduce_mut"><a class="header" href="#dispatchreduce_mut"><code>Dispatch::reduce_mut</code></a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dispatch.reduce_mut(|counter| counter.count += 1);
<span class="boring">}
</span></code></pre></pre>
<h3 id="dispatchreduce_mut_callback"><a class="header" href="#dispatchreduce_mut_callback"><code>Dispatch::reduce_mut_callback</code></a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let onclick = dispatch.reduce_mut_callback(|counter| counter.count += 1);
html! {
    &lt;button {onclick}&gt;{&quot;Increment (+1)&quot;}&lt;/button&gt;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="dispatchreduce_mut_callback_with"><a class="header" href="#dispatchreduce_mut_callback_with"><code>Dispatch::reduce_mut_callback_with</code></a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let onchange = dispatch.reduce_mut_callback_with(|counter, e: Event| {
    let input = e.target_unchecked_into::&lt;HtmlInputElement&gt;();

    if let Ok(val) = input.value().parse() {
        counter.count = val;
    }
});

html! {
    &lt;input placeholder=&quot;Set counter&quot; {onchange} /&gt;
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="mutate-state-predictably"><a class="header" href="#mutate-state-predictably">Mutate state predictably</a></h1>
<p>Yewdux supports predictable mutation. Simply define your message and apply it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Msg {
    AddOne,
}

impl Reducer&lt;Counter&gt; for Msg {
    fn apply(self, counter: Rc&lt;Counter&gt;) -&gt; Rc&lt;Counter&gt; {
        match self {
            Msg::AddOne =&gt; Counter { count: counter.count + 1 },
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="tip"><a class="header" href="#tip">Tip</a></h3>
<p><code>Rc::make_mut</code> is handy if you prefer CoW:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Reducer&lt;Counter&gt; for Msg {
    fn apply(self, mut counter: Rc&lt;Counter&gt;) -&gt; Rc&lt;Counter&gt; {
        let state = Rc::make_mut(&amp;mut counter);

        match self {
            Msg::AddOne =&gt; state.count += 1,
        };

        counter
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="dispatchapply"><a class="header" href="#dispatchapply"><code>Dispatch::apply</code></a></h3>
<p>Execute immediately.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dispatch.apply(Msg::AddOne);
<span class="boring">}
</span></code></pre></pre>
<h3 id="dispatchapply_callback"><a class="header" href="#dispatchapply_callback"><code>Dispatch::apply_callback</code></a></h3>
<p>Generate (you guessed it) a callback.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let onclick = dispatch.apply_callback(|_| Msg::AddOne);
html! {
    &lt;button {onclick}&gt;{&quot;Increment (+1)&quot;}&lt;/button&gt;
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="future-support"><a class="header" href="#future-support">Future support</a></h1>
<p>Because a <code>Dispatch</code> may be created and executed from anywhere, Yewdux has innate future support.
Just use it normally, no additonal setup is needed.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>yew::platform::spawn_local(async {
    let user = get_user().await;
    Dispatch::&lt;User&gt;::new().set(user);
})
<span class="boring">}
</span></code></pre></pre>
<h2 id="async-associated-functions"><a class="header" href="#async-associated-functions">Async associated functions</a></h2>
<p>For stores that have async methods, dispatch provides some options for your convenience.</p>
<h3 id="dispatchreduce_future"><a class="header" href="#dispatchreduce_future"><code>Dispatch::reduce_future</code></a></h3>
<p>Executes immediately.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dispatch
    .reduce_future(|state| async move {
        let mut state = state.as_ref().clone();
        state.update_user().await;

        state
    })
    .await;
<span class="boring">}
</span></code></pre></pre>
<h3 id="dispatchreduce_mut_future"><a class="header" href="#dispatchreduce_mut_future"><code>Dispatch::reduce_mut_future</code></a></h3>
<p>For the <code>CoW</code> approach. Note <code>Box::pin</code> is required here. This is due to a current limitation of
Rust, and should be phased out in the future.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dispatch
    .reduce_mut_future(|state| {
        Box::pin(async move {
            state.update_user().await;
        })
    })
    .await;
<span class="boring">}
</span></code></pre></pre>
<h2 id="async-callbacks"><a class="header" href="#async-callbacks">Async callbacks</a></h2>
<p>You can also create callbacks that execute a future when called. Note these are simple wrappers over
<code>yew::platform::spawn_local</code>.</p>
<h3 id="dispatchreduce_future_callback"><a class="header" href="#dispatchreduce_future_callback"><code>Dispatch::reduce_future_callback</code></a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cb = dispatch.reduce_future_callback(|state| async move {
    let mut state = state.as_ref().clone();
    state.update_user().await;

    state
});
<span class="boring">}
</span></code></pre></pre>
<h3 id="dispatchreduce_mut_future_callback"><a class="header" href="#dispatchreduce_mut_future_callback"><code>Dispatch::reduce_mut_future_callback</code></a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cb = dispatch.reduce_mut_future_callback(|state| {
    Box::pin(async move {
        state.update_user().await;
    })
});
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading-state"><a class="header" href="#reading-state">Reading state</a></h1>
<p>Reading global state is a little trickier than it might seem. Most of the time, components need to
not only know the current state, but also get the new state whenever it changes. For that, we must
subscribe to changes.</p>
<h2 id="subscribing-to-changes"><a class="header" href="#subscribing-to-changes">Subscribing to changes</a></h2>
<p>Components need to know when to re-render for changes. To do this they can subscribe to a store.</p>
<p>Functional hooks like <code>use_store</code> will subscribe automatically.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `counter` is automatically updated when global state changes.
let (counter, dispatch) = use_store::&lt;Counter&gt;();
<span class="boring">}
</span></code></pre></pre>
<p>You may also subscribe manually, as shown below. At the cost of boilerplate, doing it this way
allows much finer control.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

use yew::prelude::*;
use yewdux::prelude::*;

struct MyComponent {
    dispatch: Dispatch&lt;Counter&gt;,
    counter: Rc&lt;Counter&gt;,

}

enum Msg {
    UpdateCounter(Rc&lt;Counter&gt;),
}

impl Component for MyComponent {
    type Properties = ();
    type Message = Msg;

    fn create(ctx: &amp;Context&lt;Self&gt;) -&gt; Self {
        // The callback for receiving updates to state.
        let callback = ctx.link().callback(Msg::UpdateCounter);
        // Subscribe to changes in state. New state is received in `update`. Be sure to save this,
        // dropping it will unsubscribe.
        let dispatch = Dispatch::&lt;Counter&gt;::subscribe(callback);
        Self {
            // Get the current state.
            counter: dispatch.get(),
            dispatch,
        }
    }

    fn update(&amp;mut self, ctx: &amp;Context&lt;Self&gt;, msg: Msg) -&gt; bool {
        match msg {
            // Receive new state.
            Msg::UpdateCounter(counter) =&gt; {
                self.counter = counter;

                // Only re-render this component if count is greater that 0 (for example).
                if self.counter.count &gt; 0 {
                    true
                } else {
                    false
                }
            }
        }
    }

    ...
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="immediate-state"><a class="header" href="#immediate-state">Immediate state</a></h2>
<p>It is also possible to retrieve the current state of a store without subscribing to changes. This is
useful when you don't really care when/if state has changed, just what the current value is.</p>
<p><code>Dispatch::get</code> will lookup the current value immediately:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let state = dispatch.get();
<span class="boring">}
</span></code></pre></pre>
<h1 id="selectors"><a class="header" href="#selectors">Selectors</a></h1>
<p>Sometimes a component will only care about a particular part of state, and only needs to re-render
when that part changes. For this we have the <code>use_selector</code> hook.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default, Clone, PartialEq, Store)]
struct User {
    first_name: String,
    last_name: String,
}

#[function_component]
fn DisplayFirst() -&gt; Html {
    // This will only re-render when the first name has changed. It will **not** re-render if any
    // other field has changed.
    //
    // Note: we are cloning a string. Probably insignificant for this example, however
    // sometimes it may be beneficial to wrap fields that are expensive to clone in an `Rc`.
    let first_name = use_selector(|state: &amp;User| state.first_name.clone());

    html! {
        &lt;p&gt;{ first_name }&lt;/p&gt;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="capturing-your-environment"><a class="header" href="#capturing-your-environment">Capturing your environment</a></h2>
<p>For selectors that need to capture variables from their environment, be sure to provide them as
dependencies to <code>use_selector_with_deps</code>. Otherwise your selector won't update correctly!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default, Clone, PartialEq, Store)]
struct Items {
    inner: HashMap&lt;u32, String&gt;,
}

#[derive(Clone, PartialEq, Properties)]
struct DisplayItemProps {
    item_id: u32,
}

#[function_component]
fn DisplayItem(props: &amp;DisplayItemProps) -&gt; Html {
    // For multiple dependencies, try using a tuple: (dep1, dep2, ..)
    let item = use_selector_with_deps(
        |state: &amp;Items, item_id| state.inner.get(item_id).cloned(),
        props.item_id,
    );
    // Only render the item if it exists.
    let item = match item {
        Some(item) =&gt; item,
        None =&gt; return Default::default(),
    };

    html! {
        &lt;p&gt;{ item }&lt;/p&gt;
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="listeners"><a class="header" href="#listeners">Listeners</a></h1>
<p>Listeners are component-less subscribers. They are used to describe side-effects that should happen
whenever state changes. They live for application lifetime, and are created with <code>init_listener</code>.</p>
<p>To see how this is useful, let's recreate store <a href="./persistence.html">persistence</a>. The full example can
be seen <a href="https://github.com/intendednull/yewdux/blob/master/examples/listener/src/main.rs">here</a>.</p>
<p>First we define <code>StorageListener</code>. Its implementation is super simple: whenever state changes we
save it to local storage.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Doesn't hold any state, so we'll use an empty type.
struct StorageListener;
impl Listener for StorageListener {
    // Here's where we say which store we want to subscribe to.
    type Store = State;

    fn on_change(&amp;mut self, state: Rc&lt;Self::Store&gt;) {
        storage::save(state.as_ref(), storage::Area::Local).expect(&quot;unable to save state&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we define our store. To initialize <code>StorageListener</code>, we call <code>init_listener(StorageListener)</code>
in the <code>Store::new</code> method. This ensures it is always created along with <code>State</code>.</p>
<p><strong>NOTE</strong>: Successive calls to <code>init_listener</code> on the same type will replace the existing listener
with the new one.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default, Clone, PartialEq, Eq, Deserialize, Serialize)]
struct State {
    count: u32,
}

impl Store for State {
    fn new() -&gt; Self {
        init_listener(StorageListener);

        storage::load(storage::Area::Local)
            .ok()
            .flatten()
            .unwrap_or_default()
    }

    fn should_notify(&amp;self, other: &amp;Self) -&gt; bool {
        self != other
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally we use the store normally. If all goes well, your counter will now persist through page
visits!</p>
<pre><pre class="playground"><code class="language-rust">#[function_component]
fn App() -&gt; Html {
    let (state, dispatch) = use_store::&lt;State&gt;();
    let onclick = dispatch.reduce_mut_callback(|state| state.count += 1);

    html! {
        &lt;&gt;
        &lt;p&gt;{ state.count }&lt;/p&gt;
        &lt;button {onclick}&gt;{&quot;+1&quot;}&lt;/button&gt;
        &lt;/&gt;
    }
}

fn main() {
    yew::Renderer::&lt;App&gt;::new().render();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>That about covers basic usage! Now here are various tips and patterns to help you develop your app.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-default-store-values"><a class="header" href="#setting-default-store-values">Setting default store values</a></h1>
<p>The best way to define the default value of your store is by manually implementing <code>Default</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Store)]
struct MyStore {
    foo: String,
    bar: String,
}

impl Default for MyStore {
    fn default() -&gt; Self {
        Self {
            foo: &quot;foo&quot;.to_string(),
            bar: &quot;bar&quot;.to_string(),
        }
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>However sometimes you may need additional context to set the initial value of your store. To do
this, there are a couple options.</p>
<p>You can set the value at the beginning of your application, before your app renders (like in your
main fn).</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // .. other setup logic and whatnot
    Dispatch::&lt;MyStore&gt;::new().set(MyStore { ... });
    // ... now you can render your app!
}
</code></pre></pre>
<p>Or inside some component using <code>use_effect_with_deps</code>, provided deps of <code>()</code>. Be sure to keep it in
a root component!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use_effect_with_deps(
    move || {
        // .. other setup logic and whatnot
        Dispatch::&lt;MyStore&gt;::new().set(MyStore { ... });
        || {}
    },
    (),
);
<span class="boring">}
</span></code></pre></pre>
<p>Keep in mind your store will still be initialized with <code>Store::new</code> (usually that's set to
<code>Default::default()</code>), however, because Rust is awesome, no fields are allocated initially, and
overwriting is very cheap.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
